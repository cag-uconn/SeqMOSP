\section{Sequential MOSP}

This paper characterizes the computational performance of the NP-hard multi-objective shortest path (MOSP) problem. Given a weighted graph with non-negative edge weights, the shortest path problem computes the minimum-cost path from a start node to a goal/destination node in the graph~\cite{tarjan_book}. In a multi-objective setting, each edge is given a non-negative cost vector (constant length for each edge in a graph), with each element corresponding to an objective. When these objectives conflict, no single path can optimize all of them simultaneously. MOSP aims to find a set of Pareto-optimal (non-dominated) solution paths, where a path is Pareto-optimal if no single objective of the path can be improved without causing at least one of the other objectives to deteriorate in quality. During execution, the intermediate path cost vectors form the so-called \textit{Pareto-optimal labels} that comprise potential candidate solutions. However, computing this front is computationally hard \cite{serafini_1987, hansen_1980, BREUGEM_2017, Ehrgott_2005, Papadimitriou_2000}. As the number of objectives and nodes increases, so does the computational complexity and the number of Pareto-optimal solution paths~\cite{Ren2022}. 

Consider an input graph $G=(V,E,c)$ with a set of nodes $V$ and edges $E$. For each edge $e \in E$, there is a non-negative cost vector ${c}(e)$ of length $d$ objectives. Given a source node $v_s$ and a goal node $v_g$ in the graph $G$, the path from $v_s$ to an intermediate node $v$ is defined as a label\footnote{MOSP literature also identifies a label as a candidate path~\cite{Ren2022, MARTINS198485, sanders_ipdps13}.} $l=(v,\hat{g})$, a tuple represented by a sequence of nodes where each node is connected to its predecessor on the path and $\hat{g}$ denotes the path cost vector from $v_s$ to $v$, calculated as the sum of the cost vectors $c(e)$ for all edges present on the path. For simplicity, we denote $v(l)$ to be the vertex and $\hat{g}(l)$ to be the cost vector contained in $l$.
Since multiple objectives may compete, MOSP introduces a dominance check such that given two labels $l$ and $l^*$ with $d$ objectives, $l$ dominates $l^*$ (denoted $l \succeq l^*$) if and only if they share the same node ($v(l)=v(l^*)$) and $\hat{g}(l) \succeq \hat{g}(l^*)$ (i.e., $\hat{g}(l)[i] \leq \hat{g}(l^*)[i], \forall i \in {1,2,...,d}$, and $\hat{g}(l)[i] < \hat{g}(l^*)[i], \exists i \in {1,2,...,d}$). 
All non-dominated paths from $v_s$ to $v_g$ constitute the \emph{Pareto-optimal} solution set. MOSP aims to find a \emph{cost-unique} Pareto-optimal solution set where no two labels in the subset have the same cost vector. 

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figs/LabelFigureBig.pdf}
    \caption{Comparison of (a) single objective vs. (b) multi-objective intermediate labels between the source node $v_s$ and an intermediate node $v$. A new candidate label $l^*$ is shown alongside the associated label-level operations.}
    \label{fig:Label}
\end{figure}

In a single-objective shortest path, there can be only one minimum solution label for each node in the graph. 
As seen in Figure~\ref{fig:Label}(a), this is computed using a singular cost comparison for a given node in the graph. However, MOSP does not guarantee a single solution path, as multiple non-dominated labels can exist from the start node to any other node in the graph.
When a new candidate label $l^*$ is discovered, a \textbf{dominance check} must be performed to verify if the accumulated cost vector for any previous labels for that node $v$ dominates the cost vector for $l^*$. The label $l^*$ must be compared with all previously found non-dominated labels to $v$, as illustrated in Figure~\ref{fig:Label}(b). If it is not dominated, then the mutually non-dominated set of labels at $v$ must be updated with the new label, possibly \textbf{pruning} existing solutions if the new label dominates them. 
These dominance and pruning checks are expensive, especially as the number of non-dominated labels increases with the number of nodes and objectives~\cite{ijcai2023p757}.

To efficiently compute the Pareto-optimal solution front, MOSP algorithms are developed based on the multiobjective extension of the A* algorithm designed for single-objective search~\cite{10.1145/1754399.1754400, ICAPS20paper199, 10.1145/115234.115368}. Multi-objective A* (MOA*), unlike A* that exits once the first solution is found, needs to store a set of Pareto-optimal labels to the goal node. 
A New Approach to Multi-Objective A* (NAMOA*)~\cite{10.1145/1754399.1754400} and its variants EMOA*, NAMOA*-dr, LTMOA*, and LazyLTMOA* use \textbf{consistent heuristic} for the A* search to ensure that an exact set of solution labels are computed to the goal node. 
%NAMOA* handles an arbitrary number of objectives to compute an exact set of solution paths, thus serving as the basis for the proposed MOS algorithm in this paper.  
A heuristic vector $\hat{h}(v)$ is an \emph{admissible} heuristic {such that it dominates all Pareto-optimal solution labels from node $v$ to the goal node~\cite{10.1145/1754399.1754400}.} One method to derive this heuristic is to compute the single-source shortest path (SSSP) from the goal node for each objective. The resulting shortest paths to all nodes in the graph represent the lower bound path costs, defined as $\hat{h}(v(l))$.
A vector $\hat{f}(l)$ denotes the estimated path cost from the start node to the goal node for a given label, calculated as $\hat{f}(l) = \hat{g}(l) + \hat{h}(v(l))$. This heuristic cost is used in MOSP algorithms to efficiently compute the non-dominated paths, to find a \emph{cost-unique} Pareto-optimal solution set where no two labels in the subset have the same cost vector.

MOSP algorithms are a unique class of graph processing as they execute a nondeterministic number of labels for each node in the graph, and each label performs an unstructured and variable number of computations. Depending on the graph characteristics and how the objectives compete, each label per node may explore an arbitrary number of adjacent labels. For each neighbor label, a nondeterministic number of labels must be compared via dominance and pruning checks. The complexity of these operators relies on the number of candidate labels being compared, which increases with the number of nodes and objectives. Given the irregular complexity of each label processed, MOSP algorithms center around key data structures and operators.

\vspace{0.05cm}
\noindent \textbf{\emph{OPEN}} data structure is a queue of labels prioritized by $\hat{f}(l)$ in increasing lexicographic order of objectives. The labels can be prioritized based on the lexicographic order to guarantee that a Pareto-optimal label is extracted and processed in each iteration (or frontier in traditional graph terminology). A priority queue (PQ) data structure can be used to ensure a label with the highest chance of remaining in the final solution is processed. Other options for organizing labels include FIFO or Stack organization of labels, which introduces complexity and work efficiency tradeoffs.

\vspace{0.05cm}
\noindent \textbf{\emph{Frontier Set}} data structure $\alpha(u)$ for each node $u$ holds all non-dominated labels $l$ at node $u$. Each label in $\alpha(u)$ is a non-dominated partial solution path from $v_s$ to $u$. For illustration purposes, $\alpha(v_s)$ maintains the Pareto-optimal solution from $P$ holding the frontier set at the goal node, $v_s$. The output of the MOSP algorithm is the exact set of Pareto-optimal solutions in $P$.

\vspace{0.05cm}
\noindent \textbf{\emph{NotDominated}~(l, S, cost)} operator compares the label $l$ with labels in a given set $S$ to verify if a label exists in $S$ that dominates $l$. The cost specifies whether the path-cost ($\Hat{g}$) or heuristic-cost ($\Hat{f}$) is used for the dominance checks.
It returns \emph{false} if $l$ is dominated by a label in $S$, and returns \emph{true} otherwise.

\vspace{0.1cm}
\noindent \textbf{\emph{Prune}~(S, l, cost)} operator searches through all labels in a given set $S$, and removes all labels in $S$ that are dominated by $l$ using path-cost ($\Hat{g}$) or heuristic-cost ($\Hat{f}$).

Next, representative MOSP algorithms are described to illustrate the execution flow of multi-objective graph problems.

\subsubsection{NAMOA* Algorithm}


\begin{algorithm}[!ht]
\captionsetup{font=small}
\footnotesize
\caption{NAMOA* MOSP Algorithm original}\label{alg:NAMOA}
\begin{algorithmic}[1]
    \While{OPEN $\neq \emptyset$}
        \State $l \gets$ OPEN.pop()
        \State $G_{OP}(v(l))$.remove($l$)
        \State $G_{CL}(v(l))$.insert($l$)
        \If{$v(l)=v_g$}
            \State Prune($OPEN, l, \Hat{f})$
            \State Prune($P, l, \Hat{f})$ \Comment{skip, if PQ OPEN}
            \If{NotDominated(l, P, $\Hat{f}$)}
                \State $P$.insert($l$)
            \EndIf
        \Else 
            \ForAll {$v'\in$ GetNeighbors($v(l)$)}
                \State $l'\gets (v', \hat{g}(l) + \hat{c}(v(l),v'))$; parent($l'\gets l$)
                \State $\Hat{f}(l')\gets \hat{g}(l') + \hat{h}(v(l'))$
                \If{NotDominated($l', P,\Hat{f}$)) \textbf{and}\\
                \hspace{5.6em}NotDominated($l',G_{OP}(v(l')),\Hat{g}$) \textbf{and}\\
                \hspace{5.6em}NotDominated($l',G_{CL}(v(l')),\Hat{g}$)}
                    \State Prune($G_{CL}(v(l')),l',\Hat{g})$ \Comment{skip, if PQ OPEN}
                    \State Prune($G_{OP}(v(l')),l',\Hat{g})$
                    \State OPEN.insert($l'$)
                    \State $G_{OP}(v(l'))$.insert($l'$)
                \EndIf
            \EndFor
        \EndIf
    \EndWhile
    \State \Return $P$
\end{algorithmic}
\end{algorithm}

The open ($G_{OP}$) is organized as a per-node set and mirrors all labels in OPEN for efficient execution of the NotDominated and Prune operators. The closed ($G_{CL}$) contains the non-dominated solution labels in the frontier set of each node, while $P$ manages the frontier set at the goal node. 

Algorithm~\ref{alg:NAMOA} lists the pseudocode for the execution flow of NAMOA*. Assuming a priority queue OPEN, at each iteration, the label with lexicographically lowest heuristic-cost $\hat{f}$ is extracted (line 2). This label $l$ is removed from $G_{OP}$ and inserted into $G_{CL}$ (lines 3 and 4) to update the frontier set. 

If $l$ is at the goal node ($v(l)=v_g$, line 5), all labels heuristic-dominated by $l$ in OPEN are pruned (line 6). This operation requires a computationally expensive full index search through OPEN. The pruned labels are also removed from $G_{OP}$. To ensure the $P$ set contains only globally Pareto-optimal solution labels, the labels in $P$ dominated by $l$ are pruned (line 7). The sequential PQ-based OPEN guarantees that the label extracted is globally Pareto-optimal and no label already inserted in $P$ is dominated by the current label. However, when OPEN is relaxed, this guarantee is invalid, and thus, the prune $P$ is needed. NotDominated is called to check if $l$ is not dominated by any labels in $P$ (line 8), and if successful, $l$ is inserted into the Pareto-optimal solution front $P$ (line 9). Since $P$ contains only goal node labels, either path-cost ($\Hat{g}$) or heuristic-cost ($\Hat{f}$) can be used for the Prune and NotDominated operators on $P$.


If $l$ is \emph{not} at the goal node, then all neighbors $v'$ of $v(l)$ are explored (line 11). For each $v'$, a new candidate label $l'$ is expanded. The parent pointer of $l'$ is set to $l$ to allow solution path reconstruction once execution concludes (line 12). The new $\hat{f}(l')$ is also computed (line 13). NotDominated is called for $l'$ (line 14) to check if its lower-bound path estimate ($\hat{f}(l')$) is dominated by any goal-node solutions in $P$. The dominance checks are also performed to see if any label path-cost ($\Hat{g}$) in $G_{OP}(v(l'))$ or $G_{CL}(v(l'))$ dominates $l'$ (lines 15-16). If $l'$ is not dominated, all labels from $G_{OP}(v(l'))$ and $G_{CL}(v(l'))$ dominated by $l'$ are pruned (lines 17-18). The labels pruned from $G_{OP}$ are also pruned from OPEN. The label $l'$ is now inserted into OPEN and $G_{OP}$ (lines 19-20). For the same reason as the goal node label, pruning of $G_{CL}$ is unnecessary (line 17) for PQ-based OPEN, as only globally Pareto-optimal labels are inserted for node $v'$. Thus, $l'$ will not find any label to dominate in $G_{CL}(v(l'))$.

Once OPEN is empty, the algorithm terminates, and $P$ contains the final labels representing the Pareto-optimal solution paths (also referred to as exact solutions). 


\subsubsection{NAMOA* Variant}

\begin{algorithm}[!ht]
\captionsetup{font=small}
\footnotesize
\caption{NAMOA* no prune OPEN  Algorithm}\label{alg:NAMOA2025}
\begin{algorithmic}[1]
    \While{OPEN $\neq \emptyset$}
        \State $l \gets$ OPEN.pop()
        \State $G_{OP}(v(l))$.remove($l$)
        \If{NotDominated(l, P, $\Hat{f}$)}
            \State $G_{CL}(v(l))$.insert($l$)
            \If{$v(l)=v_g$}
                \State Prune($P, l, \Hat{f})$ \Comment{skip, if PQ OPEN}
                \State $P$.insert($l$)
            \Else 
                \ForAll {$v'\in$ GetNeighbors($v(l)$)}
                    \State $l'\gets (v', \hat{g}(l) + \hat{c}(v(l),v'))$; parent($l'\gets l$)
                    \State $\Hat{f}(l')\gets \hat{g}(l') + \hat{h}(v(l'))$
                    \If{NotDominated($l', P,\Hat{f}$) \textbf{and}\\
                    \hspace{7.1em}NotDominated($l',G_{CL} (v(l')),\Hat{g}$) \textbf{and}\\
                    \hspace{7.1em}NotDominated($l',G_{OP}(v(l')),\Hat{g}$)}
                    \State Prune($G_{CL}(v(l')),l',\Hat{g})$ \Comment{skip, if PQ OPEN}
                    \State Prune($G_{OP}(v(l')),l',\Hat{g})$
                    \State OPEN.insert($l'$)
                    \State $G_{OP}(v(l'))$.insert($l'$)
                    \EndIf
                \EndFor
            \EndIf 
        \EndIf
    \EndWhile
    \State \Return $P$
\end{algorithmic}
\end{algorithm}

%\vspace{1em}

Algorithm~\ref{alg:NAMOA2025} lists the pseudocode for a NAMOA* variant from the literature. 
When a label $l$ is extracted from OPEN and $G_{OP}$, it is pruned if heuristic-cost ($\Hat{f}$) is dominated by another label in $P$ (line 4). Otherwise, the label is inserted into $G_{CL}$ (line 5) and expanded. 
If $l$ is at the goal node, this variant inserts into $P$. The prune OPEN full index search is not needed since the dominance check on label extraction (line 4) lazily prunes labels from OPEN. 
If $l$ is \emph{not} at the goal node, all operators consistent with Algorithm~\ref{alg:NAMOA} are carried out.

\subsubsection{LTMOA* (or EMOA*) Algorithm}

\begin{algorithm}[!ht]
\captionsetup{font=small}
\footnotesize
\caption{LTMOA* Linear Time MOSP Algorithm}\label{alg:LTMOA}
\begin{algorithmic}[1]
    \While{OPEN $\neq \emptyset$}
        
        \State $l \gets$ OPEN.pop()

        \If{NotDominated($l, P,\Hat{f}$) \textbf{and}\\
        \hspace{2.7em}NotDominated($l,G_{CL} (v(l)),\Hat{g}$)}

            \State Prune($G_{CL}(v(l)),l,\Hat{g})$ \Comment{skip, if PQ OPEN??}
            \State $G_{CL}(v(l))$.insert($l$)

            \If{$v(l)=v_g$}
                \State Prune($P, l, \Hat{f})$ \Comment{skip, if PQ OPEN. EMOA* does not skip!}
                \State $P$.insert($l$)
            \Else 
                %\State Prune($G_{CL}(v(l)),l,\Hat{g})$ 
                %\State $G_{CL}(v(l))$.insert($l$)
                \ForAll {$v'\in$ GetNeighbors($v(l)$)}
                    \State $l'\gets (v', \hat{g}(l) + \hat{c}(v(l),v'))$; parent($l'\gets l$)
                    \State $\Hat{f}(l')\gets \hat{g}(l') + \hat{h}(v(l'))$
                    \If{NotDominated($l', P,\Hat{f}$) \textbf{and}\\
                    \hspace{7.1em}NotDominated($l',G_{CL} (v(l')),\Hat{g}$)}
                        %\State Prune($G_{CL}(v(l')),l',\Hat{g})$ \Comment{skip, if PQ OPEN}
                        %\State Prune($G_{OP}(v(l')),l',\Hat{g})$
                        \State OPEN.insert($l'$)
                        %\State $G_{OP}(v(l'))$.insert($l'$)
                    \EndIf
                \EndFor
            \EndIf 

        \EndIf

    \EndWhile
    \State \Return $P$
\end{algorithmic}
\end{algorithm}

Algorithm~\ref{alg:LTMOA} lists the pseudocode for Linear Time MOA* (LTMOA*) that performs dominance
check in linear time using a linked list or an array to store the $G_{CL}$ for each node. LTMOA* does not maintain the $G_{OP}$. When extracting (label $l$) or generating (label $l'$), it prunes if heuristic-cost ($\Hat{f}$) is dominated by another label in $P$ (lines 3 and 14), and path-cost ($\Hat{g}$) is dominated by another label in $G_{CL}$ for that node (lines 4 and 15). Suppose the extracted or generated label is dominated in either $G_{CL}$ or $P$. In that case, it is discarded, and the current iteration ends since this label cannot lead to a cost-unique Pareto-optimal solution. LTMOA* does not check if the generated label $l'$ is dominated by labels in OPEN associated with the same node. Thus, multiple labels for the same node dominating each other may co-exist in OPEN. Since no pruning is done with labels in OPEN, there is a risk of having a larger OPEN compared to NAMOA*. 

After determining the label $l$ for expansion, it is used to update the frontier set $\alpha(v(l))$. All labels from $G_{CL}(v(l))$ dominated by $l$ are pruned (line 5), and label $l$ is inserted into $G_{CL}$ (line 6).

If $l$ is at the goal node ($v(l)=v_g$, line 7), this means a cost-unique solution is found. First, all labels from $P$ dominated by $l$ are pruned (line 8). This operation may not be required if PQ OPEN extracts globally pareto-optimal labels, ensuring label $l$ does not dominate any labels in $P$. Then, label $l$ is inserted into $P$ (line 9). 

%If $l$ is \emph{not} at the goal node, all labels from $G_{CL}(v(l))$ dominated by $l$ are pruned (line 9), and label $l$ is inserted into $G_{CL}$ (line 10). Then, 
If $l$ is \emph{not} at the goal node, the label $l$ is expanded. For each $v'$, a new candidate label $l'$ is expanded (line 12) and $\hat{f}(l')$ is also computed (line 13). Then, dominance checks for labels in $P$ and $G_{CL}(v(l'))$ are invoked on label $l'$ to verify if $l'$ is dominated and should be discarded or not. If $l'$ is not dominated, it is added to OPEN (line 16). 
%For the same reason as the goal node label, the pruning of $G_{CL}$ is unnecessary (line 16) for PQ-based OPEN since only globally Pareto-optimal labels are inserted in it for the node $v'$. Thus, $l'$ will not find any label to dominate in $G_{CL}(v(l'))$.

When generating a new label $l'$, LTMOA* performs fewer dominance checks compared to NAMOA* as it does not need to operate over $G_{OP}(v(l'))$. NAMOA* only iterates over $P$ when extracting a label, but iterates over $G_{OP}(v(l'))$ twice; first to check if any label path cost ($\hat{g}$) in $G_{OP}(v(l'))$ dominates $l'$, and if $l'$ is not dominated, all labels from $G_{OP}(v(l'))$ dominated by $l'$ are pruned. On the other hand, LTMAO* (and EMOA*) does not perform the dominance checks with $G_{OP}(v(l'))$. Instead, it `lazily' performs more dominance checks over $G_{CL}(v(l))$ and $P$ when it extracts a label $l$ for expansion. Therefore, LTMOA* (or EMOA*) performs fewer dominance checks for a label if the size of $G_{CL}$ for a node is smaller than $G_{OP}$.



\subsubsection{LazyLTMOA* Variant} 

\begin{algorithm}[!ht]
\captionsetup{font=small}
\footnotesize
\caption{LazyLTMOA* Variant of LTMOA*}\label{alg:LazyLTMOA}
\begin{algorithmic}[1]
    \While{OPEN $\neq \emptyset$}
        
        \State $l \gets$ OPEN.pop()

        \If{NotDominated($l, P,\Hat{f}$) \textbf{and}\\
        \hspace{2.7em}NotDominated($l,G_{CL} (v(l)),\Hat{g}$)}

            \State Prune($G_{CL}(v(l)),l,\Hat{g})$ \Comment{skip, if PQ OPEN??}
            \State $G_{CL}(v(l))$.insert($l$)

            \If{$v(l)=v_g$}
                \State Prune($P, l, \Hat{f})$ \Comment{skip, if PQ OPEN. EMOA* does not skip!}
                \State $P$.insert($l$)
            \Else 
                %\State Prune($G_{CL}(v(l)),l,\Hat{g})$ 
                %\State $G_{CL}(v(l))$.insert($l$)
                \ForAll {$v'\in$ GetNeighbors($v(l)$)}
                    \State $l'\gets (v', \hat{g}(l) + \hat{c}(v(l),v'))$; parent($l'\gets l$)
                    \State $\Hat{f}(l')\gets \hat{g}(l') + \hat{h}(v(l'))$
                    \State OPEN.insert($l'$)%\If{NotDominated($l', P,\Hat{f}$) \textbf{and}\\
                    %\hspace{7.1em}NotDominated($l',G_{CL} (v(l')),\Hat{g}$)}
                        %\State Prune($G_{CL}(v(l')),l',\Hat{g})$ \Comment{skip, if PQ OPEN}
                        %\State OPEN.insert($l'$)
                    %\EndIf
                \EndFor
            \EndIf 

        \EndIf

    \EndWhile
    \State \Return $P$
\end{algorithmic}
\end{algorithm}

The LTMOA* is extended using an even `lazier' approach, where dominance checks during label generation are removed. Algorithm~\ref{alg:LazyLTMOA} lists the pseudocode for a LazyLTMOA* that performs dominance checks only when a label $l$ is extracted from OPEN. It only iterates over $G_{CL}$ and $P$ when extracting a label from OPEN, and hence performs the fewest dominance checks.


